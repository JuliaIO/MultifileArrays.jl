var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultifileArrays","category":"page"},{"location":"#MultifileArrays","page":"Home","title":"MultifileArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MultifileArrays.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MultifileArrays]","category":"page"},{"location":"#MultifileArrays.load_series-Tuple{Any, Any}","page":"Home","title":"MultifileArrays.load_series","text":"A = load_series(f, filepattern; dir=pwd())\n\nCreate a lazily-loaded array A from a set of files. f(filename) should create an array from the filename, and filepattern is a pattern matching the names of the desired files. The file names should have a numeric portion that indicates ordering; ordering is numeric rather than alphabetical, so left-padding with zeros is optional.\n\nExamples\n\nSuppose you are currently in a directory with files image01.tiff ... image12.tiff. Then either\n\njulia> using FileIO, MultifileArrays\n\njulia> img = load_series(load, \"image*.tiff\")\n\nor the more precise regular-expression form\n\njulia> img = load_series(load, r\"image(\\d+).tiff\");\n\nsuffice to load the image files.\n\n\n\n\n\n","category":"method"},{"location":"#MultifileArrays.load_series-Union{Tuple{F}, Tuple{F, AbstractArray{<:AbstractString}, AbstractArray}} where F","page":"Home","title":"MultifileArrays.load_series","text":"A = load_series(f, filenames::AbstractArray{<:AbstractString}, buffer::AbstractArray)\n\nCreate a lazily-loaded array A from a set of files. f is a function to load the data from a specific file into an array equivalent to buffer, meaning that\n\nf(buffer, filename)\n\nshould fill buffer with the contents of filename.\n\nfilenames should be an array of file names with shape equivalent to the trailing dimensions of A, i.e., those that follow the dimensions of buffer.\n\nThe advantage of this syntax is that it provides greater control than load_series(f, filepattern) over the choice of files and the shape of the overall output.\n\nExamples\n\nSuppose you are currently in a directory with files image_z=1_t=1.tiff through image_z=5_t=30.tiff, where each file corresponds to a 2d (x, y) slice and the filename indicates the z and t coordinates. You could reshape filenames into matrix form\n\n5×30 Matrix{String}:\n \"image_z=1_t=1.tiff\"  \"image_z=1_t=2.tiff\"  \"image_z=1_t=3.tiff\"  …  \"image_z=1_t=29.tiff\"  \"image_z=1_t=30.tiff\"\n \"image_z=2_t=1.tiff\"  \"image_z=2_t=2.tiff\"  \"image_z=2_t=3.tiff\"     \"image_z=2_t=29.tiff\"  \"image_z=2_t=30.tiff\"\n \"image_z=3_t=1.tiff\"  \"image_z=3_t=2.tiff\"  \"image_z=3_t=3.tiff\"     \"image_z=3_t=29.tiff\"  \"image_z=3_t=30.tiff\"\n \"image_z=4_t=1.tiff\"  \"image_z=4_t=2.tiff\"  \"image_z=4_t=3.tiff\"     \"image_z=4_t=29.tiff\"  \"image_z=4_t=30.tiff\"\n \"image_z=5_t=1.tiff\"  \"image_z=5_t=2.tiff\"  \"image_z=5_t=3.tiff\"     \"image_z=5_t=29.tiff\"  \"image_z=5_t=30.tiff\"\n\nand then\n\njulia> buf = load(first(filenames));\n\njulia> img = load_series(load!, filenames, buf)\n\nwould create a 4-dimensional output. load! would ideally load directly into its first argument, but could be defined as\n\nload!(dest, filename) = copyto!(dest, load(filename))\n\nif needed.\n\n\n\n\n\n","category":"method"},{"location":"#MultifileArrays.select_series-Tuple{AbstractString}","page":"Home","title":"MultifileArrays.select_series","text":"filenames = select_series(filepattern; dir=pwd())\n\nCreate a vector of filenames from filepattern. filepattern may be a string containing a * character (which is treated as a wildcard match), or a regular expression capturing a digit-substring. In either case, the */capture extracts an integer that determines file order.\n\n\n\n\n\n","category":"method"}]
}
