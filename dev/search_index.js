var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultifileArrays","category":"page"},{"location":"#MultifileArrays","page":"Home","title":"MultifileArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultifileArrays implements \"lazy concatenation\" of file data. The primary function, load_series, will load data from disk on-demand and store \"slices\" in a temporary buffer. This allows you treat a series of files as if they are a large contiguous array.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Further examples are described in the API section, but a simple demo using a directory dir with a bunch of PNG files might be","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using MultifileArrays, FileIO\n\njulia> img = load_series(load, \"myimage_*.png\"; dir)","category":"page"},{"location":"#Performance-tips","page":"Home","title":"Performance tips","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"While MultifileArrays is convenient, there are some performance caveats to keep in mind:","category":"page"},{"location":"","page":"Home","title":"Home","text":"to reduce the number of times that a file needs to be (re)loaded from disk, iteration over the resulting array is best done in a manner consistent with the file-by-file slicing.\noperations than can be performed \"slice at a time\" (e.g., visualization with ImageView) are even more optimized than scalar (single-element) indexing, as the latter must check whether the supplied slice-index corresponds to the currently loaded file upon each access.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For uncompressed data, alternative approaches that exploit memory-mapping may yield better performance. The StackViews package allows you to \"glue\" such arrays together.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MultifileArrays]","category":"page"},{"location":"#MultifileArrays.MultifileArrays","page":"Home","title":"MultifileArrays.MultifileArrays","text":"MultifileArrays creates lazily-loaded multidimensional arrays from files. Here are the main functions:\n\nload_chunked: Load an array from chunks stored in files in filenames.\nload_series: Create a lazily-loaded array A from a set of files.\nselect_series: Create a vector of filenames from filepattern.\n\n\n\n\n\n","category":"module"},{"location":"#MultifileArrays.get_order_size-Tuple{Any}","page":"Home","title":"MultifileArrays.get_order_size","text":"get_order_ranges(order; strides=nothing)\n\nreceives a Vector of NTuples and calculates the number of unique entries in each dimension.\n\nArguments\n\norder: A Vector of NTuples.\nstrides: The strides of the dimensions in the filenames. Default is nothing which means that the strides are ignored.\n\nReturns\n\nthe ranges of the dimensions in the filenames.\n\n\n\n\n\n","category":"method"},{"location":"#MultifileArrays.load_chunked","page":"Home","title":"MultifileArrays.load_chunked","text":"A = load_chunked(lazyloader, filenames)\n\nLoad an array from chunks stored in files in filenames. filenames must be shaped so that it is \"extended\" along the dimension of concatenation.\n\nWhen each chunk has the same size and is equivalent to a single slice of the final array, load_series may yield better performance.\n\nExamples\n\nSuppose you have 2 files, myimage_1.tiff and myimage_2.tiff, with the first storing 1000 two-dimensional images and the second storing 555 images of the same shape. Then you can load a contiguous 3d array with\n\njulia> julia> filenames = reshape([\"myimage_1.tiff\", \"myimage_2.tiff\"], (1, 1, 2))\n1×1×2 Array{String, 3}:\n[:, :, 1] =\n \"myimage_1.tiff\"\n\n[:, :, 2] =\n \"myimage_2.tiff\"\n\njulia> img = load_chunked(fn -> load(fn; mmap=true), filenames);\n\njulia> size(img)\n(512, 512, 1555)\n\nIn the TiffImages package, mmap=true allows you to \"virtually\" load the data by memory-mapping, supporting arrays much larger than computer memory.\n\nnote: Note\nload_chunked requires that you manually load the BlockArrays package.\n\n\n\n\n\n","category":"function"},{"location":"#MultifileArrays.load_series-Tuple{Any, Any}","page":"Home","title":"MultifileArrays.load_series","text":"A = load_series(f, filepattern; dir=pwd())\n\nCreate a lazily-loaded array A from a set of files. f(filename) should create an array from the filename, and filepattern is a pattern matching the names of the desired files. The file names should have one or multiple numeric portions that indicates ordering; ordering is numeric rather than alphabetical, so left-padding with zeros is optional. See select_series for details about the pattern-matching.\n\nExamples\n\nSuppose you are currently in a directory with files image01.tiff ... image12.tiff. Then either\n\njulia> using FileIO, MultifileArrays\n\njulia> img = load_series(load, \"image*.tiff\")\n\nor the more precise regular-expression form\n\njulia> img = load_series(load, r\"image(\\d+).tiff\");\n\nsuffice to load the image files. If multiple wildcard characters are present, the order of the digits in the filenames is used to determine the order of the files.\n\njulia> using FileIO, MultifileArrays\n\njulia> img = load_series(load, \"image_z=*_t=*.tiff\")\n\nbut the files need to be ordered in a grid-like fashion, otherwise the matching files will only be collected along one dimension.\n\n\n\n\n\n","category":"method"},{"location":"#MultifileArrays.load_series-Union{Tuple{F}, Tuple{F, AbstractArray{<:AbstractString}, AbstractArray}} where F","page":"Home","title":"MultifileArrays.load_series","text":"A = load_series(f, filenames::AbstractArray{<:AbstractString}, buffer::AbstractArray)\n\nCreate a lazily-loaded array A from a set of files. f is a function to load the data from a specific file into an array equivalent to buffer, meaning that\n\nf(buffer, filename)\n\nshould fill buffer with the contents of filename.\n\nfilenames should be an array of file names with shape equivalent to the trailing dimensions of A, i.e., those that follow the dimensions of buffer.\n\nThe advantage of this syntax is that it provides greater control than load_series(f, filepattern) over the choice of files and the shape of the overall output.\n\nnote: Note\nStackViews provides an alternative approach that may yield better performance if you can either load all the files into memory at once or use lazy mmap-based loading.\n\nExamples\n\nSuppose you are currently in a directory with files image_z=1_t=1.tiff through image_z=5_t=30.tiff, where each file corresponds to a 2d (x, y) slice and the filename indicates the z and t coordinates. You could reshape filenames into matrix form\n\n5×30 Matrix{String}:\n \"image_z=1_t=1.tiff\"  \"image_z=1_t=2.tiff\"  \"image_z=1_t=3.tiff\"  …  \"image_z=1_t=29.tiff\"  \"image_z=1_t=30.tiff\"\n \"image_z=2_t=1.tiff\"  \"image_z=2_t=2.tiff\"  \"image_z=2_t=3.tiff\"     \"image_z=2_t=29.tiff\"  \"image_z=2_t=30.tiff\"\n \"image_z=3_t=1.tiff\"  \"image_z=3_t=2.tiff\"  \"image_z=3_t=3.tiff\"     \"image_z=3_t=29.tiff\"  \"image_z=3_t=30.tiff\"\n \"image_z=4_t=1.tiff\"  \"image_z=4_t=2.tiff\"  \"image_z=4_t=3.tiff\"     \"image_z=4_t=29.tiff\"  \"image_z=4_t=30.tiff\"\n \"image_z=5_t=1.tiff\"  \"image_z=5_t=2.tiff\"  \"image_z=5_t=3.tiff\"     \"image_z=5_t=29.tiff\"  \"image_z=5_t=30.tiff\"\n\nand then\n\njulia> buf = load(first(filenames));\n\njulia> img = load_series(load!, filenames, buf)\n\nwould create a 4-dimensional output. load! would ideally load directly into its first argument, but could be defined as\n\nload!(dest, filename) = copyto!(dest, load(filename))\n\nif needed.\n\n\n\n\n\n","category":"method"},{"location":"#MultifileArrays.select_series-Tuple{AbstractString}","page":"Home","title":"MultifileArrays.select_series","text":"filenames = select_series(filepattern; dir=pwd())\n\nCreate a vector of filenames from filepattern. filepattern may be a string containing a * character or a regular expression capturing a digit-substring. The */capture extracts an integer that determines file order.\n\nWhen dir contains no extraneous files, and the filenames are ordered alphabetically in the desired sequence, then readdir is a simpler alternative. select_series may be useful for cases that don't satisfy both of these conditions.\n\nExamples\n\nSuppose you have a directory with myimage_1.png, myimage_2.png, ..., myimage_12.png. Then\n\njulia> select_series(\"myimage_*.png\")\n12-element Vector{String}:\n \"myimage_1.png\"\n \"myimage_2.png\"\n ⋮\n \"myimage_12.png\"\n\nnote: Note\nThe myimage_ part of the string is essential: the * must match only integer data. The \"generic wildcard\" meaning of * is implemented in Glob.\n\n\n\n\n\n","category":"method"}]
}
